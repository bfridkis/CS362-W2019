        -:    0:Source:cardEffects.c
        -:    0:Graph:cardEffects.gcno
        -:    0:Data:cardEffects.gcda
        -:    0:Runs:28
        -:    0:Programs:9
        -:    1:#include "cardEffects.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4:
        -:    5://  Note:
        -:    6://                        Main bug in adventurer function :
        -:    7://			(Before the introduction of additional bugs for assignment 2) 
        -:    8://		
        -:    9://		If there are not at least 2 treasure cards in
        -:   10://		the set of cards making up the deck and discard piles, the function will
        -:   11://		start "consuming" the hand itself in search of treasures. These will be
        -:   12://		used erroneously if found. If there are not at least 2 treasures in the
        -:   13://		set of cards making up the deck, discard, and hand (i.e. the set of all
        -:   14://		cards for the given player), the function will eventually fault the program
        -:   15://		by attempting to access memory representing the player's hand array
        -:   16:// 		(state->hand[player]) in continuous search of treasures. The faulty mechanism
        -:   17://		lies in the fact that drawCard will simply return a -1 once it has placed
        -:   18://		all cards in the temp hand after depleting both the deck and discard piles,
        -:   19://		whereafter adventurerEffect still erroneously assumes drawCard is still adding 
        -:   20://		to the hand. The hand itself is then added to the temp hand until no cards are
        -:   21://		remaining (i.e. handCount has reached. Finally it (handCount) will reach -1,
        -:   22://		and the attempt on line 33 to access state->hand[currentPlayer][-1] will crash
        -:   23://		the program.
        -:   24:
      618:   25:int adventurerEffect(int currentPlayer, struct gameState *state){
        -:   26:	int temphand[MAX_HAND];
      618:   27:	int drawntreasure = 0, z = 0;
     7734:   28:	while(drawntreasure<2){
     6498:   29:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
      132:   30:	  shuffle(currentPlayer, state);
        -:   31:	}
     6498:   32:	drawCard(currentPlayer, state);
     6498:   33:	int cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     6498:   34:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
     1236:   35:	  drawntreasure++;
        -:   36:	else{
     5262:   37:	  temphand[z]=cardDrawn;
     5262:   38:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     5262:   39:	  z++;
        -:   40:	}
        -:   41:      }
     6498:   42:      while(z-1>=0){
     5262:   43:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     5262:   44:	z=z-1;
        -:   45:      }
      618:   46:      return 0;
        -:   47:}
        -:   48:
      412:   49:int smithyEffect(int currentPlayer, struct gameState *state, int handPos){
        -:   50:	int i;
        -:   51:	//+3 Cards
     1648:   52:      for (i = 0; i < 3; i++)
        -:   53:	{
     1236:   54:	  drawCard(currentPlayer, state);
        -:   55:	}
        -:   56:			
        -:   57:      //discard card from hand
      412:   58:      discardCard(handPos, currentPlayer, state, 0);
      412:   59:      return 0;
        -:   60:}
        -:   61:
      202:   62:int cutpurseEffect(int currentPlayer, struct gameState *state, int handPos){
      202:   63:	updateCoins(currentPlayer, state, 2);
        -:   64:      int i, j, k;
     1006:   65:	  for (i = 0; i < state->numPlayers; i++)
        -:   66:	{
      804:   67:	  if (i != currentPlayer)
        -:   68:	    {
     3473:   69:	      for (j = 0; j < state->handCount[i]; j++)
        -:   70:		{
     3471:   71:		  if (state->hand[i][j] == copper)
        -:   72:		    {
      600:   73:		      discardCard(j, i, state, 0);
      600:   74:		      break;
        -:   75:		    }
     2871:   76:		  if (j == state->handCount[i])
        -:   77:		    {
    #####:   78:		      for (k = 0; k < state->handCount[i]; k++)
        -:   79:			{
        -:   80:			  if (DEBUG)
        -:   81:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -:   82:			}	
    #####:   83:		      break;
        -:   84:		    }		
        -:   85:		}
        -:   86:					
        -:   87:	    }
        -:   88:				
        -:   89:	}				
        -:   90:
        -:   91:      //discard played card from hand
      202:   92:      discardCard(handPos, currentPlayer, state, 0);			
        -:   93:
      202:   94:      return 0;
        -:   95:}
        -:   96:
    #####:   97:int minionEffect(int currentPlayer, struct gameState *state, int choice1,
        -:   98:	int choice2, int handPos){
        -:   99:	  //+1 action
    #####:  100:      state->numActions++;
        -:  101:			
        -:  102:      //discard card from hand
    #####:  103:      discardCard(handPos, currentPlayer, state, 0);
        -:  104:			
    #####:  105:      if (choice1)		//+2 coins
        -:  106:	{
    #####:  107:	  state->coins = state->coins + 2;
        -:  108:	}
        -:  109:			
    #####:  110:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  111:	{
        -:  112:	  //discard hand
    #####:  113:	  while(numHandCards(state) > 0)
        -:  114:	    {
    #####:  115:	      discardCard(handPos, currentPlayer, state, 0);
        -:  116:	    }
        -:  117:				
        -:  118:	  //draw 4
        -:  119:	  int i, j;
    #####:  120:	  for (i = 0; i < 4; i++)
        -:  121:	    {
    #####:  122:	      drawCard(currentPlayer, state);
        -:  123:	    }
        -:  124:				
        -:  125:	  //other players discard hand and redraw if hand size > 4
    #####:  126:	  for (i = 0; i < state->numPlayers; i++)
        -:  127:	    {
    #####:  128:	      if (i != currentPlayer)
        -:  129:		{
    #####:  130:		  if ( state->handCount[i] >= 4 )
        -:  131:		    {
        -:  132:		      //discard hand
    #####:  133:		      while( state->handCount[i] > 1 )
        -:  134:			{
    #####:  135:			  discardCard(handPos, i, state, 0);
        -:  136:			}
        -:  137:							
        -:  138:		      //draw 4
    #####:  139:		      for (j = 0; j < 3; j++)
        -:  140:			{
    #####:  141:			  drawCard(i, state);
        -:  142:			}
        -:  143:		    }
        -:  144:		}
        -:  145:	    }
        -:  146:				
        -:  147:	}
    #####:  148:      return 0; 
        -:  149:}
        -:  150:
    #####:  151:int ambassadorEffect(int currentPlayer, struct gameState *state, int choice1,
        -:  152:	int choice2, int handPos){
    #####:  153:	int j = 0;		//used to check if player has enough cards to discard
        -:  154:
    #####:  155:      if (choice2 > 2 || choice2 < 0)
        -:  156:	{
    #####:  157:	  return -1;				
        -:  158:	}
        -:  159:
    #####:  160:      if (choice1 == handPos)
        -:  161:	{
    #####:  162:	  return -1;
        -:  163:	}
        -:  164:
        -:  165:	  int i;
    #####:  166:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  167:	{
    #####:  168:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  169:	    {
    #####:  170:	      j++;
        -:  171:	    }
        -:  172:	}
    #####:  173:      if (j < choice2)
        -:  174:	{
    #####:  175:	  return -1;				
        -:  176:	}
        -:  177:
        -:  178:      if (DEBUG) 
        -:  179:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  180:
        -:  181:      //increase supply count for choosen card by amount being discarded
    #####:  182:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  183:			
        -:  184:      //each other player gains a copy of revealed card
    #####:  185:      for (i = 0; i < state->numPlayers; i++)
        -:  186:	{
    #####:  187:	  if (i != currentPlayer)
        -:  188:	    {
    #####:  189:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -:  190:	    }
        -:  191:	}
        -:  192:
        -:  193:      //discard played card from hand
    #####:  194:      discardCard(handPos, currentPlayer, state, 0);			
        -:  195:
        -:  196:      //trash copies of cards returned to supply
    #####:  197:      for (j = 0; j < choice2; j++)
        -:  198:	{
    #####:  199:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  200:	    {
    #####:  201:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -:  202:		{
    #####:  203:		  discardCard(i, currentPlayer, state, 1);
    #####:  204:		  break;
        -:  205:		}
        -:  206:	    }
        -:  207:	}			
        -:  208:
    #####:  209:      return 0;
        -:  210:}
