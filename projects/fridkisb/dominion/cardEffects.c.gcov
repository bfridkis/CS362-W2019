        -:    0:Source:cardEffects.c
        -:    0:Graph:cardEffects.gcno
        -:    0:Data:cardEffects.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "cardEffects.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4:
        -:    5://  Note:
        -:    6://                        Main bug in adventurer function :
        -:    7://			(Before the introduction of additional bugs for assignment 2) 
        -:    8://		
        -:    9://		If there are not at least 2 treasure cards in the set of cards making up the 
        -:   10://		deck and discard piles, the function will start "consuming" the hand itself in 
        -:   11://		search of treasures. If treasures are found in the hand, they will be used
        -:   12://		erroneously, as if they'd been gained from the deck. If there are not at least 
        -:   13://		2 treasures in the set of cards making up the deck, discard, and hand (i.e. the 
        -:   14://		set of all cards for the given player), the function will eventually fault the 
        -:   15://		program by attempting to access the player's hand array using an invalid index 
        -:   16://		(state->hand[player][-1]) in continuous search of treasures. The faulty mechanism
        -:   17://		lies in the fact that drawCard will simply return a -1 once it has placed
        -:   18://		all cards in the temp hand after depleting both the deck and discard piles,
        -:   19://		where after adventurerEffect erroneously assumes drawCard is still adding 
        -:   20://		to the hand. The hand itself is then added to the temp hand until no cards are
        -:   21://		remaining (i.e. handCount has reached 0. Finally it (handCount) will reach -1,
        -:   22://		and the attempt to access state->hand[currentPlayer][-1] will crash
        -:   23://		the program. This logic has obvious ramifications, even when the deck is lacking
        -:   24://		at least 2 treasures but the hand can make up the difference. In this instance,
        -:   25://		the program will not crash outright, but the hand will be erroneously depleted
        -:   26://		as non-treasure cards are removed until sufficient treasure is found.
        -:   27:
function adventurerEffect called 4 returned 100% blocks executed 100%
        4:   28:int adventurerEffect(int currentPlayer, struct gameState *state){
        -:   29:	int temphand[MAX_HAND];
        4:   30:	int drawntreasure = 0, z = 0;
       36:   31:	while(drawntreasure<2){
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
       28:   32:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        7:   33:	  shuffle(currentPlayer, state);
call    0 returned 100%
        -:   34:	}
       28:   35:	drawCard(currentPlayer, state);
call    0 returned 100%
       28:   36:	int cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
       28:   37:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
branch  2 taken 84% (fallthrough)
branch  3 taken 16%
branch  4 taken 5% (fallthrough)
branch  5 taken 95%
        8:   38:	  drawntreasure++;
        -:   39:	else{
       20:   40:	  temphand[z]=cardDrawn;
       20:   41:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
       20:   42:	  z++;
        -:   43:	}
        -:   44:      }
       28:   45:      while(z-1>=0){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       20:   46:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
       20:   47:	z=z-1;
        -:   48:      }
        4:   49:      return 0;
        -:   50:}
        -:   51:
function smithyEffect called 0 returned 0% blocks executed 0%
    #####:   52:int smithyEffect(int currentPlayer, struct gameState *state, int handPos){
        -:   53:	int i;
        -:   54:	//+3 Cards
    #####:   55:      for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:   56:	{
    #####:   57:	  drawCard(currentPlayer, state);
call    0 never executed
        -:   58:	}
        -:   59:			
        -:   60:      //discard card from hand
    #####:   61:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:   62:      return 0;
        -:   63:}
        -:   64:
function cutpurseEffect called 0 returned 0% blocks executed 0%
    #####:   65:int cutpurseEffect(int currentPlayer, struct gameState *state, int handPos){
    #####:   66:	updateCoins(currentPlayer, state, 2);
call    0 never executed
        -:   67:      int i, j, k;
    #####:   68:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:   69:	{
    #####:   70:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:   71:	    {
    #####:   72:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -:   73:		{
    #####:   74:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -:   75:		    {
    #####:   76:		      discardCard(j, i, state, 0);
call    0 never executed
    #####:   77:		      break;
        -:   78:		    }
        -:   79:			//The if statement below can never be true...
    #####:   80:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -:   81:		    {
    #####:   82:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -:   83:			{
        -:   84:			  if (DEBUG)
        -:   85:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -:   86:			}	
    #####:   87:		      break;
        -:   88:		    }		
        -:   89:		}
        -:   90:					
        -:   91:	    }
        -:   92:				
        -:   93:	}				
        -:   94:
        -:   95:      //discard played card from hand
    #####:   96:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -:   97:
    #####:   98:      return 0;
        -:   99:}
        -:  100:
function minionEffect called 0 returned 0% blocks executed 0%
    #####:  101:int minionEffect(int currentPlayer, struct gameState *state, int choice1,
        -:  102:	int choice2, int handPos){
        -:  103:	  //+1 action
    #####:  104:      state->numActions++;
        -:  105:			
        -:  106:      //discard card from hand
    #####:  107:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  108:			
    #####:  109:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  110:	{
    #####:  111:	  state->coins = state->coins + 2;
        -:  112:	}
        -:  113:			
    #####:  114:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  115:	{
        -:  116:	  //discard hand
    #####:  117:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  118:	    {
    #####:  119:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  120:	    }
        -:  121:				
        -:  122:	  //draw 4
        -:  123:	  int i, j;
    #####:  124:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  125:	    {
    #####:  126:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  127:	    }
        -:  128:				
        -:  129:	  //other players discard hand and redraw if hand size > 4
    #####:  130:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  131:	    {
    #####:  132:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  133:		{
    #####:  134:		  if ( state->handCount[i] >= 4 )
branch  0 never executed
branch  1 never executed
        -:  135:		    {
        -:  136:		      //discard hand
    #####:  137:		      while( state->handCount[i] > 1 )
branch  0 never executed
branch  1 never executed
        -:  138:			{
    #####:  139:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -:  140:			}
        -:  141:							
        -:  142:		      //draw 4
    #####:  143:		      for (j = 0; j < 3; j++)
branch  0 never executed
branch  1 never executed
        -:  144:			{
    #####:  145:			  drawCard(i, state);
call    0 never executed
        -:  146:			}
        -:  147:		    }
        -:  148:		}
        -:  149:	    }
        -:  150:				
        -:  151:	}
    #####:  152:      return 0; 
        -:  153:}
        -:  154:
function ambassadorEffect called 0 returned 0% blocks executed 0%
    #####:  155:int ambassadorEffect(int currentPlayer, struct gameState *state, int choice1,
        -:  156:	int choice2, int handPos){
    #####:  157:	int j = 0;		//used to check if player has enough cards to discard
        -:  158:
    #####:  159:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  160:	{
    #####:  161:	  return -1;				
        -:  162:	}
        -:  163:
    #####:  164:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -:  165:	{
    #####:  166:	  return -1;
        -:  167:	}
        -:  168:
        -:  169:	  int i;
    #####:  170:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  171:	{
    #####:  172:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  173:	    {
    #####:  174:	      j++;
        -:  175:	    }
        -:  176:	}
    #####:  177:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -:  178:	{
    #####:  179:	  return -1;				
        -:  180:	}
        -:  181:
        -:  182:      if (DEBUG) 
        -:  183:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  184:
        -:  185:      //increase supply count for choosen card by amount being discarded
    #####:  186:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  187:			
        -:  188:      //each other player gains a copy of revealed card
    #####:  189:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  190:	{
    #####:  191:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  192:	    {
    #####:  193:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -:  194:	    }
        -:  195:	}
        -:  196:
        -:  197:      //discard played card from hand
    #####:  198:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -:  199:
        -:  200:      //trash copies of cards returned to supply
    #####:  201:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -:  202:	{
    #####:  203:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  204:	    {
    #####:  205:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -:  206:		{
    #####:  207:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####:  208:		  break;
        -:  209:		}
        -:  210:	    }
        -:  211:	}			
        -:  212:
    #####:  213:      return 0;
        -:  214:}
        -:  215:
function council_roomEffect called 0 returned 0% blocks executed 0%
    #####:  216:int council_roomEffect(int currentPlayer, struct gameState *state, int handPos){
        -:  217:	int i;
        -:  218:	//+4 Cards
    #####:  219:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  220:	{
    #####:  221:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  222:	}
        -:  223:			
        -:  224:	  //+1 Buy
    #####:  225:	  state->numBuys++;
        -:  226:			
        -:  227:	  //Each other player draws a card
    #####:  228:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  229:	{
    #####:  230:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  231:		{
    #####:  232:		  drawCard(i, state);
call    0 never executed
        -:  233:		}
        -:  234:	}
        -:  235:	
        -:  236:	  //put played card in played card pile
    #####:  237:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  238:	
    #####:  239:	return 0;
        -:  240:}
