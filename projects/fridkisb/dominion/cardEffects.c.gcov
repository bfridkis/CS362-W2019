        -:    0:Source:cardEffects.c
        -:    0:Graph:cardEffects.gcno
        -:    0:Data:cardEffects.gcda
        -:    0:Runs:18
        -:    0:Programs:8
        -:    1:#include "cardEffects.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4:
        -:    5://  Note:
        -:    6://                        Main bug in adventurer function :
        -:    7://			(Before the introduction of additional bugs for assignment 2) 
        -:    8://		
        -:    9://		If there are not at least 2 treasure cards in the set of cards making up the 
        -:   10://		deck and discard piles, the function will start "consuming" the hand itself in 
        -:   11://		search of treasures. If treasures are found in the hand, they will be used
        -:   12://		erroneously, as if they'd been gained from the deck. If there are not at least 
        -:   13://		2 treasures in the set of cards making up the deck, discard, and hand (i.e. the 
        -:   14://		set of all cards for the given player), the function will eventually fault the 
        -:   15://		program by attempting to access the player's hand array using an invalid index 
        -:   16://		(state->hand[player][-1]) in continuous search of treasures. The faulty mechanism
        -:   17://		lies in the fact that drawCard will simply return a -1 once it has placed
        -:   18://		all cards in the temp hand after depleting both the deck and discard piles,
        -:   19://		where after adventurerEffect erroneously assumes drawCard is still adding 
        -:   20://		to the hand. The hand itself is then added to the temp hand until no cards are
        -:   21://		remaining (i.e. handCount has reached 0. Finally it (handCount) will reach -1,
        -:   22://		and the attempt to access state->hand[currentPlayer][-1] will crash
        -:   23://		the program. This logic has obvious ramifications, even when the deck is lacking
        -:   24://		at least 2 treasures but the hand can make up the difference. In this instance,
        -:   25://		the program will not crash outright, but the hand will be erroneously depleted
        -:   26://		as non-treasure cards are removed until sufficient treasure is found.
        -:   27:
function adventurerEffect called 0 returned 0% blocks executed 0%
    #####:   28:int adventurerEffect(int currentPlayer, struct gameState *state){
        -:   29:	int temphand[MAX_HAND];
    #####:   30:	int drawntreasure = 0, z = 1;
    #####:   31:	while(drawntreasure<3){
branch  0 never executed
branch  1 never executed
    #####:   32:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:   33:	  shuffle(currentPlayer, state);
call    0 never executed
        -:   34:	}
    #####:   35:	drawCard(currentPlayer, state);
call    0 never executed
    #####:   36:	int cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:   37:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   38:	  drawntreasure++;
        -:   39:	else{
    #####:   40:	  temphand[z]=cardDrawn;
    #####:   41:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:   42:	  z++;
        -:   43:	}
        -:   44:      }
    #####:   45:      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:   46:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:   47:	z=z-1;
        -:   48:      }
    #####:   49:      return 0;
        -:   50:}
        -:   51:
function smithyEffect called 0 returned 0% blocks executed 0%
    #####:   52:int smithyEffect(int currentPlayer, struct gameState *state, int handPos){
        -:   53:	int i;
        -:   54:	//+3 Cards
    #####:   55:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:   56:	{
    #####:   57:	  drawCard(currentPlayer, state);
call    0 never executed
        -:   58:	}
        -:   59:			
        -:   60:      //discard card from hand
    #####:   61:      discardCard(handPos+1, currentPlayer, state, 0);
call    0 never executed
    #####:   62:      return 0;
        -:   63:}
        -:   64:
function cutpurseEffect called 0 returned 0% blocks executed 0%
    #####:   65:int cutpurseEffect(int currentPlayer, struct gameState *state, int handPos){
    #####:   66:	updateCoins(currentPlayer, state, 3);
call    0 never executed
        -:   67:      int i, j, k;
    #####:   68:	  for (i = 0; i < state->numPlayers-1; i++)
branch  0 never executed
branch  1 never executed
        -:   69:	{
    #####:   70:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:   71:	    {
    #####:   72:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -:   73:		{
    #####:   74:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -:   75:		    {
    #####:   76:		      discardCard(j, i, state, 0);
call    0 never executed
    #####:   77:		      break;
        -:   78:		    }
    #####:   79:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -:   80:		    {
    #####:   81:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -:   82:			{
        -:   83:			  if (DEBUG)
        -:   84:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -:   85:			}	
    #####:   86:		      break;
        -:   87:		    }		
        -:   88:		}
        -:   89:					
        -:   90:	    }
        -:   91:				
        -:   92:	}				
        -:   93:
        -:   94:      //discard played card from hand
    #####:   95:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -:   96:
    #####:   97:      return 0;
        -:   98:}
        -:   99:
function minionEffect called 0 returned 0% blocks executed 0%
    #####:  100:int minionEffect(int currentPlayer, struct gameState *state, int choice1,
        -:  101:	int choice2, int handPos){
        -:  102:	  //+1 action
    #####:  103:      state->numActions++;
        -:  104:			
        -:  105:      //discard card from hand
    #####:  106:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  107:			
    #####:  108:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  109:	{
    #####:  110:	  state->coins = state->coins + 2;
        -:  111:	}
        -:  112:			
    #####:  113:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  114:	{
        -:  115:	  //discard hand
    #####:  116:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  117:	    {
    #####:  118:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  119:	    }
        -:  120:				
        -:  121:	  //draw 4
        -:  122:	  int i, j;
    #####:  123:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  124:	    {
    #####:  125:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  126:	    }
        -:  127:				
        -:  128:	  //other players discard hand and redraw if hand size > 4
    #####:  129:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  130:	    {
    #####:  131:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  132:		{
    #####:  133:		  if ( state->handCount[i] >= 4 )
branch  0 never executed
branch  1 never executed
        -:  134:		    {
        -:  135:		      //discard hand
    #####:  136:		      while( state->handCount[i] > 1 )
branch  0 never executed
branch  1 never executed
        -:  137:			{
    #####:  138:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -:  139:			}
        -:  140:							
        -:  141:		      //draw 4
    #####:  142:		      for (j = 0; j < 3; j++)
branch  0 never executed
branch  1 never executed
        -:  143:			{
    #####:  144:			  drawCard(i, state);
call    0 never executed
        -:  145:			}
        -:  146:		    }
        -:  147:		}
        -:  148:	    }
        -:  149:				
        -:  150:	}
    #####:  151:      return 0; 
        -:  152:}
        -:  153:
function ambassadorEffect called 0 returned 0% blocks executed 0%
    #####:  154:int ambassadorEffect(int currentPlayer, struct gameState *state, int choice1,
        -:  155:	int choice2, int handPos){
    #####:  156:	int j = 0;		//used to check if player has enough cards to discard
        -:  157:
    #####:  158:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  159:	{
    #####:  160:	  return -1;				
        -:  161:	}
        -:  162:
    #####:  163:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -:  164:	{
    #####:  165:	  return -1;
        -:  166:	}
        -:  167:
        -:  168:	  int i;
    #####:  169:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  170:	{
    #####:  171:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  172:	    {
    #####:  173:	      j++;
        -:  174:	    }
        -:  175:	}
    #####:  176:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -:  177:	{
    #####:  178:	  return -1;				
        -:  179:	}
        -:  180:
        -:  181:      if (DEBUG) 
        -:  182:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  183:
        -:  184:      //increase supply count for choosen card by amount being discarded
    #####:  185:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  186:			
        -:  187:      //each other player gains a copy of revealed card
    #####:  188:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  189:	{
    #####:  190:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  191:	    {
    #####:  192:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -:  193:	    }
        -:  194:	}
        -:  195:
        -:  196:      //discard played card from hand
    #####:  197:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -:  198:
        -:  199:      //trash copies of cards returned to supply
    #####:  200:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -:  201:	{
    #####:  202:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  203:	    {
    #####:  204:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -:  205:		{
    #####:  206:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####:  207:		  break;
        -:  208:		}
        -:  209:	    }
        -:  210:	}			
        -:  211:
    #####:  212:      return 0;
        -:  213:}
        -:  214:
function council_roomEffect called 60030 returned 100% blocks executed 100%
    60030:  215:int council_roomEffect(int currentPlayer, struct gameState *state, int handPos){
        -:  216:	int i;
        -:  217:	//+4 Cards
   300150:  218:	  for (i = 0; i < 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  219:	{
   240120:  220:	  drawCard(currentPlayer, state);
call    0 returned 100%
        -:  221:	}
        -:  222:			
        -:  223:	  //+1 Buy
    60030:  224:	  state->numBuys++;
        -:  225:			
        -:  226:	  //Each other player draws a card
   210042:  227:	  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  228:	{
   150012:  229:	  if ( i != currentPlayer )
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:  230:		{
    89982:  231:		  drawCard(i, state);
call    0 returned 100%
        -:  232:		}
        -:  233:	}
        -:  234:	
        -:  235:	  //put played card in played card pile
    60030:  236:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  237:	
    60030:  238:	return 0;
        -:  239:}
